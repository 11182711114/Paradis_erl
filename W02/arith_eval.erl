-module(arith_eval).
-compile(export_all).

test() ->
    {test_eval,success} = test_eval(),
    {test_safe_eval, success} = test_safe_eval(),
    hooray.

test_eval() ->
    2 = eval({plus,1,1}),
    0 = eval({minus,1,1}),
    2 = eval({minus,1,-1}),
    3.0 = eval({divide,21,7}),
    26 = eval({times,13,2}),
    0 = eval({plus,125,{minus,200,325}}),
    2 = eval({plus,1,1}), 
    1.4 = eval({divide,7,5}),
    {test_eval, success}.

test_safe_eval() ->
    {ok, 2} = safe_eval({plus,1,1}),
    {ok, 0} = safe_eval({minus,1,1}),
    {ok, 2} = safe_eval({minus,1,-1}),
    {ok, 3.0} = safe_eval({divide,21,7}),
    {ok, 26} = safe_eval({times,13,2}),
    {ok, 0} = safe_eval({plus,125,{minus,200,325}}),
    {ok, 2} = safe_eval({plus,1,1}), 
    {ok, 1.4} = safe_eval({divide,7,5}),
    {error, {divide_by_zero}} = safe_eval({plus,1,{times,4,{divide,4,0}}}),   
    {error, {divide_by_zero}} = safe_eval({plus,1,{divide,4,{minus,4,{plus,3,1}}}}),
    {error, {unknown_value, monday}} = safe_eval({plus,1,monday}),
    {error, {unknown_value, saturday}} = safe_eval({plus,1,{plus,saturday,4}}),
    {test_safe_eval, success}.

% --- Eval --- %
eval(E) ->
    case E of
        {plus,A,B} ->
            eval(A) + eval(B);
        {minus,A,B} ->
            eval(A) - eval(B);
        {times,A,B} ->
            eval(A) * eval(B);
        {divide,A,B} ->
            eval(A) / eval(B);
        X when is_integer(X) or is_float(X) ->
            X;
        Any ->
            {unknown_value,Any}
    end.

% --- safe_eval --- %
safe_eval(X) ->
    Evaluator = spawn(fun evaluator/0),
    rpc(Evaluator, X).
%%TODO: Fix tuple representation
%%TODO: e.g. {error,{divide,4,{plus,-2,2}}} -> {error,{divide,4,0}}
%%? Or not?
eval_for_proc(E, From) ->
    case E of
        {plus,A,B} ->
            eval_for_proc(A, From) + eval_for_proc(B, From);
        {minus,A,B} ->
            eval_for_proc(A, From) - eval_for_proc(B, From);
        {times,A,B} ->
            eval_for_proc(A, From) * eval_for_proc(B, From);
        {divide,A,B} ->
            A_val = eval_for_proc(A, From),
            B_val = eval_for_proc(B, From),
            if 
                B_val == 0 -> throw({error, From, {divide_by_zero, E}});
                true -> continue
            end,
            A_val / B_val;
        X when is_integer(X) or is_float(X) ->
            X;
        Any ->
            throw({error, From, {unknown_value, Any}})
    end.

rpc(Pid, X) ->
    Pid ! {self(), X},
    receive
        Any -> Any
    end.

%% Note that this will crash on errors unrelated to the specified error cases,
%% making it catch error that are not generated by me does not seem like a good idea.
evaluator() ->
    try
        receive
            {From, {Op,A,B}} ->
                From ! {ok, eval_for_proc({Op, A,B}, From)};
            {From, X} when is_integer(X) or is_float(X) ->
                From ! {ok, X};
            {From, Any} ->
                From ! {unknown_value, Any};

            Any -> io:format("unknown message: ~p~n",[Any])
        end
    catch
        throw:{error, EFrom, Error} ->
            EFrom ! {error, Error}
    end,
    evaluator().